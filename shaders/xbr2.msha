name: xBR 2x
textureFiltering: NEAREST

[vertex]
attribute vec2 vPos;
attribute vec2 vUV;
attribute float vAlpha;
varying vec2 uv[3];
varying float alpha;
void main() {
    vec2 ps = 1.0 / vec2(256, 384);
    uv[0] = vUV;
    uv[1] = vec2(0.0, -ps.y);
    uv[2] = vec2(-ps.x, 0.0);
    alpha = vAlpha;
    gl_Position = vec4(vPos, 0.0, 1.0);
}
[/vertex]

[fragment]
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D tex;
varying vec2 uv[3];
varying float alpha;
const vec3 dtt = vec3(65536.0, 255.0, 1.0);
float reduce(vec3 color) {
    return dot(color, dtt);
}
void main() {
    vec2 fp = fract(uv[0] * vec2(256, 384));
    vec2 g1 = uv[1] * (step(0.5, fp.x) + step(0.5, fp.y) - 1.0) +
            uv[2] * (step(0.5, fp.x) - step(0.5, fp.y));
    vec2 g2 = uv[1] * (step(0.5, fp.y) - step(0.5, fp.x)) +
            uv[2] * (step(0.5, fp.x) + step(0.5, fp.y) - 1.0);
    vec3 B = texture2D(tex, uv[0] + g1     ).bgr;
    vec3 C = texture2D(tex, uv[0] + g1 - g2).bgr;
    vec3 D = texture2D(tex, uv[0]      + g2).bgr;
    vec3 E = texture2D(tex, uv[0]          ).bgr;
    vec3 F = texture2D(tex, uv[0]      - g2).bgr;
    vec3 G = texture2D(tex, uv[0] - g1 + g2).bgr;
    vec3 H = texture2D(tex, uv[0] - g1     ).bgr;
    vec3 I = texture2D(tex, uv[0] - g1 - g2).bgr;
    float b = reduce(B);
    float c = reduce(C);
    float d = reduce(D);
    float e = reduce(E);
    float f = reduce(F);
    float g = reduce(G);
    float h = reduce(H);
    float i = reduce(I);
    gl_FragColor.rgb = E;
    if (h==f && h!=e && ( e==g && (h==i || e==d) || e==c && (h==i || e==b) ))
    {
        gl_FragColor.rgb = mix(E, F, 0.5);
    }
    gl_fragColor.a = alpha;
}
[/fragment]
