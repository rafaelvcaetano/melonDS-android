package me.magnum.melonds.impl.emulator

import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.MessageQueue
import android.os.ParcelFileDescriptor
import java.io.FileInputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

class EmulatorMessageQueue(private val eventHandler: EventHandler) {

    fun interface EventHandler {
        /**
         * @param type The type of event generated by the emulator
         * @param data The buffer containing optional data associated with the event. The buffer is only valid for the duration of the call
         */
        fun onEmulatorEvent(type: EmulatorEventType, data: ByteBuffer)
    }

    companion object {
        private const val EVENT_SIZE_BYTES = 8 // 2 ints (type, data length)
        private const val DATA_SIZE_BYTES = 4 // 4 bytes of arbitrary data

        /**
         * Initialize the native message pipe and returns the file descriptor through which the messages will be sent.
         * @return File descriptor for reading events, or -1 on error
         */
        @JvmStatic
        private external fun initMessagePipe(): Int

        /**
         * Close the native message pipe.
         */
        @JvmStatic
        private external fun closeMessagePipe()
    }

    private val handlerThread = HandlerThread("EmulatorMessageQueue").apply { start() }
    private val handler = Handler(handlerThread.looper)

    private var messagesFileDescriptor: ParcelFileDescriptor? = null
    private var inputStream: FileInputStream? = null
    private var isRunning = false
    private val eventBuffer = ByteBuffer.allocateDirect(EVENT_SIZE_BYTES).order(ByteOrder.nativeOrder())
    private val dataBuffer = ByteBuffer.allocateDirect(DATA_SIZE_BYTES).order(ByteOrder.nativeOrder())

    fun start() {
        handler.post {
            if (isRunning) {
                return@post
            }

            val looper = Looper.myLooper() ?: throw IllegalStateException("Current thread does not have a Looper")

            val readPipeFd = initMessagePipe()
            if (readPipeFd < 0) {
                throw RuntimeException("Failed to initialize native pipe")
            }

            val fileDescriptor = ParcelFileDescriptor.adoptFd(readPipeFd)
            if (fileDescriptor == null) {
                throw RuntimeException("Failed to create ParcelFileDescriptor")
            }

            messagesFileDescriptor = fileDescriptor
            isRunning = true
            inputStream = FileInputStream(fileDescriptor.fileDescriptor)

            looper.queue.addOnFileDescriptorEventListener(fileDescriptor.fileDescriptor, MessageQueue.OnFileDescriptorEventListener.EVENT_INPUT) { _, _ ->
                if (isRunning) {
                    try {
                        readEvents()
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }

                MessageQueue.OnFileDescriptorEventListener.EVENT_INPUT
            }
        }
    }

    fun stop() {
        handler.post {
            if (!isRunning) {
                return@post
            }

            isRunning = false

            messagesFileDescriptor?.let { fd ->
                Looper.myLooper()?.queue?.removeOnFileDescriptorEventListener(fd.fileDescriptor)
                fd.close()
            }

            inputStream = null
            messagesFileDescriptor = null
            closeMessagePipe()
        }
    }

    fun cleanup() {
        handler.post {
            stop()
        }
        handlerThread.quitSafely()
    }

    private fun readEvents() {
        val currentInputStream = inputStream ?: return

        eventBuffer.clear()
        var bytesRead = currentInputStream.channel.read(eventBuffer)
        eventBuffer.position(0)

        if (bytesRead < EVENT_SIZE_BYTES) {
            return
        }

        val type = eventBuffer.int
        val dataLength = eventBuffer.int

        if (dataLength > 0) {
            dataBuffer.clear()
            bytesRead = currentInputStream.channel.read(dataBuffer)
            dataBuffer.position(0)

            if (bytesRead < dataLength) {
                return
            }
        }

        EmulatorEventType.entries.firstOrNull { it.event == type }?.let {
            eventHandler.onEmulatorEvent(it, dataBuffer)
        }
    }
}